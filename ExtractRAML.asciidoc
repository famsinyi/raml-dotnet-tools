== Metadata - Extract a RAML definition from your Web app

RAML metadata output lets you extract a RAML definition for your ASP.NET Core or WebAPI 2 app. To enable metadata output, right-click your project and choose the *Enable RAML metadata output* command.
This adds a `RamlController`, start up configurations, a razor view and other required files (css, js, etc.).
The next sections list the three ways you can access the information about your API.


=== Api Console

Run the web application and navigate to `/raml` to see the API Console. 

image::./docimages/RAML_NET_ApiConsole.png[align="center"]

You can navigate by clicking the buttons, you can see the request and responses, and try the available methods for each resource.

=== Viewing the Raw RAML

If you wish to view the RAML that is generated from your API, run your web app and navigate to `/raml/raw`. This will generate RAML 1 output, if you need the 0.8 version type '/raml/raw?version=0.8' instead.

image::./docimages/RAML_NET_RAML-v1.png[align="center"]


=== Downloading the RAML

If you wish to download the RAML as a file, run your web app and navigate to `/raml/download`. This prompts you to choose the location and file name.

=== Asp.Net Core configuration

On Asp.Net core controllers **must use attribute routing** to be able to use the functionality.
If some of your controllers use conventional routing you will need to avoid the filter to include this controllers. You can do so by modifying the configuration in the start up.
For example to remove the controller *DefaultRoutingController* from the filter you need to add an *ApiExplorerVisibilityDisabledConvention* specifying the type to the set of conventions.
This is done with the following line of code:

[source, c#]
----
options.Conventions.Add(new AMF.WebApiExplorer.ApiExplorerVisibilityDisabledConvention(typeof(DefaultRoutingController)));
----

You will need to add it to the *ConfigureServices* method of your *StartUp.cs* class:

[source, c#]
----
    public void ConfigureServices(IServiceCollection services)
    {
        // Add framework services.
        services.AddScoped<MyApiExplorerDataFilter>();
        services.AddMvc(options =>
            {
                options.Filters.AddService(typeof(AMF.WebApiExplorer.ApiExplorerDataFilter));
                options.Conventions.Add(new AMF.WebApiExplorer.ApiExplorerVisibilityEnabledConvention());
				options.Conventions.Add(new AMF.WebApiExplorer.ApiExplorerVisibilityDisabledConvention(typeof(DefaultRoutingController)));
            });
    }
----

=== Specifying Response Type in Asp.Net Core

*ResponseTypeStatusAttribute* class is used to specify the response type of a controller's action, associated to a status code.
For example:


[source, c#]
----
        [HttpGet("{id}")]
        [ResponseTypeStatus(typeof(Movie), HttpStatusCode.OK)]
        [ResponseTypeStatus(typeof(NotFoundError), HttpStatusCode.NotFound)]
        public IActionResult Get(int id)
        {
            var movie = Repositories.Movies.FindById(id);
            if (movie == null)
                return NotFound(new NotFoundError("Movie not found", id));

            return Ok(movie);
        }
----


=== Customizing the Generated RAML on your ASP.NET Core app

Some aspects of your API-like security are not automatically detected. You can customize the RAML generation process and further adjust it to your API.
To see how check the *Customizing the Generated RAML* section https://github.com/mulesoft-labs/raml-dotnetcore-apiexplorer[here]


=== Adding XML Comments to the documentation in Asp.Net WebApi 2

If you use XML comments in the headers of your controller actions, these can be included into your RAML model.

You need to generate the XML documentation, for this right click your WebApi project properties and click on the *Build* tab and select the *XML documentation file* check.

+
image::./docimages/XmlCommentsDocumentation.png[align="center"]
+

You will also need to add in the Register method of your WebApi configuration a call to the *IncludeXmlComments* method of *DocumentationProviderConfig* class.

**Note:** The default name of the XML file matches the name of the project, if you change this or the location you will need to provide the path in the *IncludeXmlComments* method. If you left the default location then there's no need to specify any parameters.

[source, c#]
----
    public static class WebApiConfig
    {
        public static void Register(HttpConfiguration config)
        {
            // Web API routes
            config.MapHttpAttributeRoutes();

            AMF.WebApiExplorer.DocumentationProviderConfig.IncludeXmlComments();
        }
    }
----


== Specifying Response Type  in Asp.Net WebApi 2

*ResponseTypeAttribute* class is used to specify the main response type of a controller's action.
For example:

[source, c#]
----
        [HttpGet("{id}")]
        [ResponseType(typeof(Movie)]
        public IActionResult Get(int id)
        {
            var movie = Repositories.Movies.FindById(id);
            return Ok(movie);
        }
----


=== Customizing the Generated RAML on your ASP.NET WebApi 2 app

Some aspects of your API-like security are not automatically detected. You can customize the RAML generation process and further adjust it to your API.
To see how check the *Customizing the Generated RAML* section https://github.com/mulesoft-labs/raml-dotnet-apiexplorer[here]
